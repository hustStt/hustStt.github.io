<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java-Note]]></title>
    <url>%2F2018%2F11%2F01%2FJava-Note%2F</url>
    <content type="text"><![CDATA[对象引用 事实上没有对象变量这样的东西存在。 只有引用到对象的变量。 对象引用变量保存的是存取对象的方法。 与C++创建对象进行比较C++创建对象方式&emsp;&emsp;在C++中我们可以采用如下两种方式来创建对象 123Dog dog;//Dog为类名Dog *p = new Dog(); 对于第一种方式而言，dog是被存储在栈中的，占用的大小是Dog类中成员变量占用内存的和，此处不包括成员方法，因为成员方法是存放在公共存储区以便所有该类的对象都可以访问的。(在栈中) 对于第二种方式则不同，该方式使用了指针，在定义*p时在栈中开辟一个4字节的空间，new Dog()时在堆中开辟一块空间，然后将该空间的首地址赋值给*p，这样，通过*p就可以找到对象在堆中的任何成员方法了。（指针在栈中，分配的内存在堆中） Java创建对象方式在C++中我们有两种创建对象的方式，而在Java中只提供了如下的一种方式 1Dog dog = new Dog(); JVM在进行内存管理时，首先会在栈中给dog分配一个空间，当new Dog();后会在堆中开辟对象的实际空间，然后将dog指向堆中的空间，这样我们就可以方法对象的成员变量了。 其中dog是一个引用，不能直接对地址进行++操作，保证内存的安全。 对于任意一个java虚拟机来说，所有的引用大小都一样，但不同的java虚拟机间可能会以不同的额方式来表示引用。 不能对引用变量进行运算。 数组12int [] nums;nums = new int[7]; 数组也是对象 数组中的每个元素都是变量。换而言之，会是8种primitive主数据类型变量中的一个，不然就是引用变量。方法的参数 方法会运用形参。调用的一方会传入实参。 Java是通过值传递的，就是说通过拷贝传递。 数据隐藏 封装的基本原则：将你的实例变量标记为私有的，并提供公有的getter与setter来控制存取动作。 private public声明与初始化实例变量 你无需初始实例变量，因为他们会有默认值。 数字的primitive（包括char）的预设为0，boolean的预设为false，而对象引用则为null。+]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[QT5.9连接oracle 驱动编译]]></title>
    <url>%2F2018%2F11%2F01%2FQT5-9-oracle%2F</url>
    <content type="text"><![CDATA[qt5.9连接oracle数据库qt msvc好像有32位跟64位的，而mingw只有32位的，之前安装的oracle数据库是64位的，所以折腾了半天都没编译好连接数据库的驱动，只好又去下载了32位的oracle 11g。 下面开始尝试编译驱动 参考教程 https://blog.csdn.net/ac_huang/article/details/36477039#t2 https://blog.csdn.net/linux12a/article/details/77278207 将原有的QMAKE_USE += oci改为QMAKE_LFLAGS +=xxxx/oci.dll 添加 INCLUDEPATH += F:\app\stt\product\11.2.0\dbhome_1\OCI\include 添加LIBPATH += F:\app\stt\product\11.2.0\dbhome_1\OCI\lib\MSVC 注释include($$shadowed($$PWD)/qtsqldrivers-config.pri) 添加include(./configure.pri) 清除 构建 重新构建 将:\plugins下面的“ sqldrivers ”文件夹复制到Qt的..\Qt\Qt5.8.0\5.8\mingw53_32\plugins下面即可]]></content>
      <categories>
        <category>QT相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[More-Effective-C++]]></title>
    <url>%2F2018%2F10%2F31%2FMore-Effective-C%2F</url>
    <content type="text"><![CDATA[“在不同时间指向不同对象”用指针pointer “总是会代表某个对象”，“一旦代表了该对象就不能够再改变”，那么应该用reference。 reinterpret_cast 操作符的转换结果几乎总是与编译平台息息相关。故reinterpret_cast不具备移植性。 操作符区别increment decrement操作符的前置和后置形式 重载函数是以其参数类型来区分彼此的，然而不论increment或decrement操作符的前置式或后置式，都没有参数。为了填补这个语言的漏洞，==++只好让后置式有一个int自变量++==，并且在它被调用时，编译器默默为该int指定一个0值。1234567891011121314151617class UPInt &#123;public: UPInt&amp; operator++(); //前置式 (prefix) ++ const UPInt operator++(int); //后置式 (prefix) ++ UPInt&amp; operator--(); const UPInt operator--(int); UPInt&amp; operator+=(int); ...&#125;;UPInt i;++i; // i.operator++();i++; // i.operator++(0);--i; // i.operator--();i--; // i.operator--(0); 前置式：increment and fetch 累加然后取出 后置式：fetch and increment 取出然后累加 1234567891011121314//前置式 累加然后取出UPInt&amp; UPInt::operator++()&#123; *this += 1; //累加 return *this; //取出&#125;//后置式 取出然后累加const UPInt UPInt::operator++(int)&#123; UPInt oldValue = *this; //取出 ++(*this); //累加 return oldValue; //返回先前被取出的值&#125; 参数的唯一目的只是为了区别前置式和后置式而已。 如果你在函数体中没有使用函数的命名参数，许多编译器会对此发出警告，一种常见的策略就是==故意略去==你不打算使用的参数的名称。 后置式increment操作符返回一个对象，代表旧值。 123UPInt i;i++++; //实施后置式 increment操作符两次i.operator++(0).operator(0); 如果返回的对象不是const的话，就可以像上述代码一样进行2次后置自增操作（显然int 不允许连续两次使用后置式increment操作符）。另外第二个operator++所改变的对象是第一个operator++返回的对象，而不是原对象，故i只完成了一次自增操作，容易引起混淆。 在效率问题上，后置式必须产生一个临时对象，需要构造也需要析构。前置式就没有如此的临时对象。故处理用户定制数据类型时，应该尽可能的使用前置式。 千万不要重载&amp;&amp;, || 和, 操作符 和C一样，C++对于“真假值表达式”采用“骤死式”评估方式。即，一旦该表达式的真假值确定，即使未完全检验，整个过程就结束了。 1234char *p;...if((p! = 0) &amp;&amp; (strlen(p) &gt; 10)) ....//只要p为null，就不会调用strlen 如果重载&amp;&amp;和||操作符，“函数调用 语义”会取代“骤死式 语义”。 123456789//如果对operator&amp;&amp;进行重载if(expression1 &amp;&amp; expression2) ...会被编译器视为以下两者之一：if(expression1.operator&amp;&amp;(expression2))//假设operator&amp;&amp;是个成员函数if(operator&amp;&amp;(expression1,expression2))//operator&amp;&amp;是个全局函数//注意如果需要用到私有成员 需使用友元 也就是说函数调用 不存在什么骤死式语义。 有所谓的==逗号操作符==吗？ 有的 C++有一些规则来定义&amp;&amp;和||面对内建类型的行为，同样也有一些规则来定义逗号操作符面对内建类型的行为。 表达式如果内含逗号，那么逗号左侧会先被评估，然后逗号的右侧再被评估；最后整个逗号表达式的结果以 ==++逗号右侧的值++== 为代表。 对于非成员函数，无法保证作为表达式一定比右侧先评估，因为两个表达式都被当做函数调用时的自变量，无法控制一个函数的自变量评估顺序。 对于成员函数，因为编译器并不强迫做这样的事情，因此不要轻率的将逗号重载。 了解各种不同意义的new和delete 请说明new operator 和operator new之间的差异 1string *ps = new string(&quot;Memory Management&quot;); 此处的new 是所谓的new operator。这个操作符是由语言内建的，不能被改变意义，总是做相同的事情，即，第一、分配足够的内存。第二、它调用了一个构造函数（constructor），为分配的内存中的对象设定初始值（初始化）。 而operator new则是跟malloc一样，唯一的任务就是分配内存，它不知道什么是构造函数（constructors），operator new 只负责内存分配。取得operator new返回的内存并将之转换为一个对象,是new operator的责任。123456//函数 operator new 通常声明如下：void * operator new(size_t size);//此函数返回一个指针，指向一块原始的、未设初值的内存//函数调用void *rawMemory = operator new(sizeof(string));]]></content>
      <categories>
        <category>C++笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++note]]></title>
    <url>%2F2018%2F07%2F04%2FC-note%2F</url>
    <content type="text"><![CDATA[C++ Note标准输入输出 输入输出能被操纵符格式化，除了setw，操纵符将永远地改变他所在应用到的输入输出流的状态，而setw的影响仅仅持续到下一个输入或输出操作。 带参数的setfill sew 需要头文件iomanip 填充字符一但设定，它的作用一直持续到重新设置为止。 setprecision用来定义浮点数的精度，默认值为6。 操纵符 效果 dec 十进制 hex 十六进制 otc 八进制 endl 换行并刷新输出流 fixed 用定点符号表示浮点数d.dd flush 刷新输出流 right 右对齐 left 左对齐 setw(n) 设置字段位数为n ws 删除空白 boolalpha 输出bool变量格式 输入输出到文件 头文件 并不需要包含iostream，不需要标准输入输出进行读写。头文件应包含fstream 定义一个ifstream类型的变量来读文件，ofstream类型的变量来写文件。 12345678910ifstream infile;ofstream outfile;infile.open(&quot;xxxx&quot;);outfile.open(&quot;xxxx&quot;);infile &gt;&gt; ---;outfile &lt;&lt; ---;infile.close();outfile.close(); 强制类型转换 C++增加了4种新类型的强制类型转换： static_cast &emsp; const_cast &emsp; dynamic_cast &emsp; reinterpret_cast static_cast static_cast是最常用的强制类型转换，它经常用来将一个数据类型转换到另一种数据类型并使用任何合理的转换方式。 12345//int -&gt; float//C语言(float)count;//C++static_cast&lt;float&gt;count; const_cast const_cast用来强制去掉常数性123const int * p;int * ptr;ptr = const_cast&lt;int *&gt; p; reinterpret_cast reinterpret_cast可用来改变指针类型，或将一个指针类型转变为整型以及将整型转呗为指针类型。 string类型 string s(5,’x’); -&gt; s = “xxxxx”; str.c_str 返回一个指向const的null结尾的char类型数组的指针。 修改字符串 删除123s.erase(); //删除全部s.erase(2); //删除第三个字符及以后的字符s.erase(2,3); //删除第三个字符开始的3个字符 插入1s1.insert(4,s2); 替换1s1.replace(4,6,s2); 交换1s1.swap(s2); 提取1s2 = s1.substr(4,6); 查找12345678s1.find(s2,int);//s1中从int开始找s2//返回大于或等于int的索引值，没找到则返回无穷大（-1？）s1.rfind(s2,int);//返回小于或等于int的索引值或为无穷大。参数s2没有给出则默认值为无穷大。s1.find_first_of(s2);//返回s1和s2都具有的第一个字符的索引，不成功则返回无穷大。//s2可以是string或者一个char字符 编程错误 操作符&lt;&lt;的优先级比关系、比较、逻辑和赋值操作符高。 混用C和C++的输入输出功能，可能会导致不可预料的错误，使用函数ios：：sync_with_stdio()可以消除这种隐患。 s1 = “W. C. “ + “Fields”;//ERROR s1 = ‘W’ + s3;//OK 关键字inline用于函数声明而不是函数定义。 默认参数应在函数声明而非函数定义中给出。 函数的返回值不是函数签名的一部分。 类 在C++中，用关键字class声明的类，其类的成员默认情况下具有类范围性质，没有为类成员指定任何访问限制符，这个成员将作为私有成员处理。 struct默认是共有的。 一个const成员函数仅能调用其他const成员函数。const成员函数不能直接或间接改变对象的状态。 time_t time(time_t* ptr); char ctime( const time_t ptr);构造函数 构造函数不能有返回值 可以对构造函数进行重载 多数情况下，编译器为类生成一个公有的默认构造函数，只有下面两种情况例外。 一个类显式声明了任何构造函数，编译器不会生成公有的默认他构造函数。如需要，则由类的设计者提供。 一个类声明了一个非公有的默认构造函数，编译器不生成公有的默认构造函数 构造函数 默认构造函数 C() 带参构造函数 拷贝构造函数 C(C&amp;) 转型构造函数 如果类的设计者不提供拷贝构造函数，编译器会自动生成一个。将源对象所有数据成员的值逐一赋值给目标对象相应的数据成员。 如果拷贝构造函数是私有的，顶层函数和其他类的成员函数就不能通过传值来传递和返回该类的对象，因为这两个操作都需要调用拷贝构造函数。 转型构造函数与隐式类型转换 声明为explicit 不隐藏 初始化const类型数据成员的唯一方法是 初始化列表 C++操作符new和new[]比C函数malloc和calloc做的更好，因为操作符new和new[]在分配存储空间的同时，还会调用相应的构造函数，而malloc和calloc无法完成这个任务。析构函数对象的摧毁出现在如下两种情况： 以某个类作为数据类型的变量超出其作用范围。 用delete操作符删除动态分配的对象。 析构函数不带参数，因此不能被重载，这样，每个类只能拥有一个析构函数。 不管是在栈上的对象，还是全局/静态区的对象，都遵循这样的顺序：越是先产生的对象越是后被销毁.类数据成员和类成员函数 类成员：属于类本身，而不属于类的对象，我们称之为类成员（class member） 属于对象的成员成为对象成员（object member）或者实例成员（instance member） static数据成员在类声明的内部声明，同时static数据成员还需要进行定义。 在所有程序块之外定义的任何变量都将自动初始化为0； static数据成员不会影响类及其他对象的sizeof 静态成员函数只能访问其他的static成员，包括数据成员和成员函数。 static成员函数既可以是inline函数，也可以是非inline函数。 访问static成员的首选方法是通过类直接访问。static成员毕竟是与类本身相关联。在成员函数内定义static变量 成员函数内的局部变量可以是static的。如果将成员函数内的某个及局部变量定义为静态变量，所有对象在调用这个成员函数时，将共享这个变量。常量指针this 在成员函数内部可以用指针常量this来访问与成员函数的调用相关联的对象。 this指针是一个常量，它不能作为赋值、递增、递减等运算的目标对象。 此外this只在非static成员函数中用才有效。、常见编程错误 在类声明的最后遗漏了一个分号。 关键字inline只能出现在该函数的声明中。 在类C的构造函数中错误地使用单一的C类型参数： 123456class C&#123; public: C(C obj); //error C(C obj, int n);//ok //...&#125; 一个static数据成员在类的声明内被声明，错误地将static数据成员定义在程序块内： 在static成员函数中使用this。 继承 新类GradStudent叫做派生类或Student的子类。原有的Student类称为基类或GradStudent的超类。 派生类GradStudent继承了Student类的所有成员函数和数据成员（构造函数、析构函数和操作符重载函数除外）。 当一个类通过公有继承方式从基类继承时，基类中的公有成员在派生类中也是公有的。 不指明继承方式关键字public时，编译器会默认继承方式为private或protected。 基类的所有私有成员仅在基类中可见，而在派生类中不可见。基类的私有成员可以由派生类继承，但在派生类中==不可见==。 使用==using==声明可以改变成员在派生类中的访问权限。例如，基类中的公有成员一般情况下被继承为公有成员，但使用using声明可以将其改为私有成员（或保护成员）。 可以通过using声明将不符合的成员函数在派生类中隐藏起来。 ==名字隐藏==： 如果派生类添加了一个数据成员，而该成员与基类中的某个数据成员同名，新的数据成员就隐藏了继承来的同名成员。 ==间接继承==： 数据成员和成员函数可以沿着继承链路来继承，继承链路包括了基类及所有派生类。 ==保护成员== ==类的私有成员==可以被类自身的成员和友元访问，但不能被包括派生类在内的其他任何类和任何普通函数访问。 ==类的保护成员==除了可以被类自身的成员和友元访问外，还可以被派生类的函数访问，但是，类的保护成员不能被任何非友元的普通函数访问。 ==类的公有成员==可以被任何普通函数和任何函数成员访问。 由此可知，派生类函数成员可以访问基类的保护成员和公有成员。除非定义为基类的成员友元，否则派生类函数成员不能访问基类的私有函数。 基类成员\派生控制 private protected public protected private protected protected public private protected public 继承机制下的构造函数与析构函数 当创建一个派生类对象时，基类的构造函数被自动调用，用来对派生类对象中的基类部分进行初始化，并完成其他一些相关事务。 如果派生类定义了自己的构造函数，则由该构造函数负责对象中“派生类添加部分”的初始化工作。 如果基类拥有构造函数但没有默认构造函数，那么派生类的构造函数必须显式地调用基类的某个构造函数。 也就是说派生类没有显式调用基类的某个构造函数的话就会调用默认构造函数（如果有的话，没有就会出错）。避免出现问题，建议为每个基类都设计一个默认构造函数。 在类的层次结构中，构造函数按基类到派生类的次序执行，西沟函数则按派生类到基类的次序执行，因此，析构函数的执行次序和构造函数的执行次序式相反的。 多态 多态就是将函数名称动态地绑定到函数入口地址的运行期绑定机制。 如果对一个函数的绑定发生在运行时刻而非编译时刻，我们就称该函数是多态的。 C++中的多态有以下三个前提条件： 必须存在一个继承体系结构 继承体系结构中的一些类必须具有同名（相同函数签名）的virtual成员函数。 至少有一个基类类型的指针或基类类型的引用。这个指针或引用可用来对virtual成员函数进行调用。 基类类型的指针可以只想任何基类对象或派生类对象。 当声明了基类的一个成员函数为虚函数后，那么即使该成员函数没有在派生类中被显式地声明为虚函数，但它在所有派生类中也将自动成为虚函数。 如果虚函数在类声明之外定义，关键字virtual仅在函数声明时需要，不需要在函数定义中使用virtual关键字。 使用动态绑定的程序会影响效率，因为虚成员函数表需要额外的空间。 纯面向对象语言由于所有的函数都以动态方式运行，因而效率的降低会相当大。 构造函数不能是虚成员函数，但析构函数可以是虚成员函数。虚析构函数 析构函数的调用时沿着继承树自下向上延伸的。 123456789101112131415161718class A&#123;public: A()&#123;&#125; ~A()&#123;&#125;&#125;calss Z : public A&#123;public: Z()&#123;&#125; ~Z()&#123;&#125;&#125;void f()&#123; A* ptr; ptr = new Z();//A() Z() delete ptr;//这里调用的是~A() //也就是说没有调用~Z() 导致内存没有释放&#125; 这是因为编译器实施的是静态绑定。编译器根据ptr的数据类型A*来决定调用哪一个析构函数，因此仅调用了~A()没有调用~Z()。 对象成员函数和类成员函数 只有非静态成员函数才可以是虚成员函数，换句话说，只有对象成员函数才可以是虚成员函数。 重载、覆盖和遮蔽在C++中，仅有虚函数是在运行期进行动态绑定的，因此仅有虚函数才具有真正意义上的多态。编译器多态机制和运行期多态机制之间的区别。 重载 重载与编译器绑定相对应，不管是成员函数还是顶层函数。 覆盖 满足以下条件： 发生覆盖的函数必须分别在父类和子类中。 子类函数与父类函数的函数签名相同 父类函数必须是虚函数 遮蔽（隐藏） 遮蔽是指子类中具有与父类同名的函数（不管参数列表是否相同），除去函数覆盖的情况。 遮蔽的条件： 子类的成员函数与父类的成员函数名必须相同 子类的虚函数无法覆盖父类的虚函数（虚函数遮蔽） 抽象基类和纯虚成员函数抽象基类之所以是抽象的，是因为不能实例化抽象基类的对象，抽象基类可以用来指明某些必须在派生类覆盖的虚函数，如果这些派生类想要拥有对象的话。只有符合下面条件的类才可以称为抽象基类： 类必须拥有一个纯虚成员函数 在纯虚成员函数声明的结尾加上=0就可将这个函数定义为纯虚成员函数。123456class ABC&#123;public: virtual coid open() = 0;&#125;;ABC obj; //*******ERROR: ABC is an abstract clss 虽然不能创建一个抽象基类的对象，但抽象基类可以拥有派生类，从抽象基类派生来的类必须覆盖基类的所有纯虚成员函数，==否则派生类也成为抽象类==，因而也不能用来创建对象。 只有虚函数才可以称为虚成员函数，非虚函数或顶层函数都不能声明为虚成员函数。 抽象基类实际上定义了一个公共接口，这个接口被所有从抽象基类派生的类共享。 因为抽象基类通常只有public成员函数，所以经常使用关键字struct赖生明抽象基类。 运行期类型识别 在运行期对类型转换操作进行检查 在运行期确定对象的类型 扩展C++提供的RTTI dynamic_cast操作符 在C++中，编译器合法的类型转换操作可能会在运行期引发错误，当转型操作涉及对象指针或引用时，更易发生错误。使用dynamic_cast操作符可用来在运行期对可疑的转型操作进行测试。 dynamic_cast 仅对多态类型有效。 typeid操作符 操作符typeid可以用来确定某个表达式的类型，要使用这个操作符，必须包含头文件typeinfo，例如，typeid操作符可用作C++的内建数据类型。 typeid不能针对非多态类型进行运行期类型检查。1daibu 操作符重载重载指的是相同的名称或符号具有不同的意义。一个重载的函数，就是一个被定义多次的函数。操作符重载也就是对+、++和[]等这样的操作符进行重新定义。 操作符()是函数调用操作符。 成员选择符(.)、成员对象选择符(.*)、域解析操作符(::)和条件操作符(?:)不能被重载。 除了复制操作符(=)之外，基类中所有被重载的操作符都将被派生类继承。 重载一个二元操作符，则操作符重载函数只有一个参数。如果我们要重载一个一元操作符，其函数不需要任何操作符。 12345678class OPair&#123;public: //.... bool operator==( const OPair&amp;) const; //....&#125;;//第一个const表示参数不会被改变。//第二个const表示调用operator==的对象不会改变。 重载不能改变操作符的优先级和语法。 用顶层函数进行操作符重载 除了内存管理操作符new、new[]、delete和delete[]之外，一个以顶层函数形式被重载的操作符必须在它的参数表中包含一个类的对象。 但下标操作符[]、赋值操作符=、函数调用操作符()和指针操作符-&gt;必须以类成员函数的形式进行重载。 因为操作符以类成员函数的形式重载时，可以保证其第一个参数是类的对象，因而当x是一个类对象时，像9[x]和6.32 = x这样的表达式就不会被程序接受。 123456C operator+( const C&amp; c1, const C&amp; c2)&#123; //....&#125;a = operator+(b,c);a = b + c; 与使用类成员函数重载二元操作符相比，只要定义了用于转型的构造函数，使用顶层函数进行重载的一个优点就是非对象操作数可以出现在操作符的左边。而使用类成员函数时，第一个操作数必须是类的对象。 friend函数类的私有成员只能被该类的成员函数和该类的friend函数访问；类的保护成员只能被该类的或其派生类的成员函数和该类的friend函数访问。\为了使函数f成为类C的friend，我们在类C的声明里使用关键字friend对f进行声明： 12345class C&#123; //... friend int f(); //..&#125; 该声明的作用是赋予f访问类C的私有成员的权利，因为不是成员函数，该声明可以放在C中的private、protect或public的任意部分。 从严格意义上来说，这不符合面向对象原则。因此friend函数建议仅在重载操作符时使用friend函数。123istream&amp; operator&gt;&gt;(istream&amp; in,Complex&amp; c)&#123; return in&gt;&gt;c.real&gt;&gt;c.imag;&#125; 拷贝构造函数与赋值操作符重载一般而言，拷贝构造函数会在以下三种情况下被使用： 当构造一个新的对象时 使用值传递来传递函数参数时 函数的返回值 当构造一个新的对象时，如： 123456class Object&#123;...&#125;;Object a;Object b = a;//此处调用的是拷贝构造函数Object c;c = a; //此处调用的是&quot;operator = &quot;Object d(a); //此处调用的是拷贝构造函数 使用值传递来传递函数参数，如： 123456class Object&#123;...&#125;;int Function_A(Object param);Object a;Function_A(a);//在调用Function_A的时候，在函数内部使用a的拷贝构造函数来获取a的副本来进行函数的处理。 函数的返回值，如： 1234567class Object&#123;...&#125;;Object GetObject()&#123; Object a; return a;&#125; 拷贝构造函数将一个对象拷贝到另一个新的对象；赋值操作符将一个对象拷贝到另一个已经存在的对象。\如果类的作者没有提供拷贝构造函数，也没有重载赋值操作符，编译器将会给这个类提供一个拷贝构造函数和一个赋值操作符。运作机制：将源对象中的每个数据成员拷贝到目标对应的数据成员中。 自增与自减操作符重载 由于编译器必须能够识别出前缀自增与后缀自增，故人为规定了用一个 int 区分，并没有实际的含义。 operator++(); 重载了前置自增操作符 operator++(int); 重载了后置自增操作符 转型操作符 operator othertype(); 内存管理操作符 new new[] delete delete[]既可以用成员函数也可以用顶层函数重载。 new操作符的重载方式有两种： 1234567void* C::operator new( size_t size)&#123;&#125;void* operator new(size_t size)&#123;&#125; C::new的调用方式为 C* c1 = new C;\系统调用了重载的C::new操作符，如果没有定义这个操作符，系统就会调用內建的new操作符。 delete操作符的重载方式也有两种： 1234567void C::operator delete(void* objPtr)&#123;&#125;void operator delete(void* objPtr)&#123;&#125; 两种重载函数均返回void，并且第一个参数必须是void*类型，用来指向需释放的空间。C::delete的调用方式如下： 123C* c1 = new C;//...delete c1; 赋值操作符是唯一不会被继承的操作符。 重载&gt;&gt;操作符用于输入时，对象必须以引用的形式传入，因为输入的数据将被写入对象，而不是对象的拷贝。因此，以下代码是错误的：123istream&amp; operator&gt;&gt;( istream&amp; in, Complex c)&#123; return in&gt;&gt; c.read&gt;&gt;c.imag;&#125; 正确的写法是：123istream&amp; operator&gt;&gt;( istream&amp; in,Complex&amp; c)&#123; return in&gt;&gt; c.read&gt;&gt;c.imag;&#125;]]></content>
      <categories>
        <category>C++笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
